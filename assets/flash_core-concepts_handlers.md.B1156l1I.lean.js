import{_ as a,c as s,a0 as t,o as n}from"./chunks/framework.p2VkXzrt.js";const u=JSON.parse('{"title":"ðŸ“š Handlers","description":"","frontmatter":{"banner-title":"Flash - Handlers","banner-description":"Learn about handlers in Flash and the different types available.","head":[["meta",{"name":"twitter:image","content":"/assets/banner-cards/flash-core-concepts-handlers.png"}],["meta",{"name":"twitter:image:src","content":"https://docs.pixel-services.com/assets/banner-cards/flash-core-concepts-handlers.png"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:height","content":"1280"}],["meta",{"name":"twitter:image:width","content":"669"}],["meta",{"name":"twitter:description","content":""}]]},"headers":[],"relativePath":"flash/core-concepts/handlers.md","filePath":"flash/core-concepts/handlers.md"}'),i={name:"flash/core-concepts/handlers.md"};function r(l,e,o,h,d,c){return n(),s("div",null,e[0]||(e[0]=[t('<h1 id="ðŸ“š-handlers" tabindex="-1">ðŸ“š Handlers <a class="header-anchor" href="#ðŸ“š-handlers" aria-label="Permalink to &quot;ðŸ“š Handlers&quot;">â€‹</a></h1><p>In Flash, handlers are the building blocks of your application logic. They are responsible for processing incoming requests, executing the necessary logic, and generating the appropriate response.</p><p>There are several types of handlers in Flash, each serving a specific purpose and providing a different level of control over the request lifecycle. Understanding the different handler types will help you structure your application logic more effectively and make the most out of Flash&#39;s powerful routing system.</p><h2 id="ðŸ“¦-routing-behavior" tabindex="-1">ðŸ“¦ Routing Behavior <a class="header-anchor" href="#ðŸ“¦-routing-behavior" aria-label="Permalink to &quot;ðŸ“¦ Routing Behavior&quot;">â€‹</a></h2><p>Before diving into the different handler types, it&#39;s essential to understand how routing works in Flash. When a request is received by the server, Flash matches the request path and method against the registered routes to find the appropriate handler. The handler is then executed, and its response is sent back to the client.</p><p>Flash supports 3 main types of routing behaviors:</p><ul><li><strong>Literal Routing</strong>: Matches the exact path specified in the route definition.</li><li><strong>Parametrized Routing</strong>: Matches paths with dynamic segments that are extracted as route parameters.</li><li><strong>Dynamic Routing</strong>: Matches any path that starts with the specified prefix and is flagged with a wildcard &quot;*&quot; character.</li></ul><h2 id="ðŸ“Œ-handler-types" tabindex="-1">ðŸ“Œ Handler Types <a class="header-anchor" href="#ðŸ“Œ-handler-types" aria-label="Permalink to &quot;ðŸ“Œ Handler Types&quot;">â€‹</a></h2><h3 id="_1-requesthandler" tabindex="-1">1. RequestHandler <a class="header-anchor" href="#_1-requesthandler" aria-label="Permalink to &quot;1. RequestHandler&quot;">â€‹</a></h3><p>The <code>RequestHandler</code> is the &quot;standard&quot; type of handler in Flash, it provides the most control over the request lifecycle and allows you to define custom logic for handling requests. You can extend the <code>RequestHandler</code> class to create custom handlers that process incoming requests and generate responses.</p><p>Because <code>RequestHandler</code> is an abstract class, you need to implement both the <code>handle()</code> method and the <code>super</code> constructor in your custom handler to define the logic that should be executed when a request is received.</p><p>Since <code>RequestHandler</code> is an abstract class, you can leverage and chain HDI&#39;s to create cleaner and more maintainable route logic (more on that in the Handler Default Implementations guide).</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">### </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SimpleHandler</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">The `SimpleHandler` is a lightweight handler that allows you to define request handling logic in a single method using lambda notation.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">It is useful </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> simple request processing tasks that don</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;t require the full lifecycle control provided by `RequestHandler`.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">To create a `SimpleHandler`, you can use the `server.get()`, `server.post()`, `server.put()`, `server.delete()` etc.</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">in general, you can use the `server.&lt;METHOD&gt;()` methods to register the handler with the server.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">The arguments for these methods are the route path and a lambda expression that provides</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">the request and response objects and defines the request handling logic.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">```java[Example]</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">server.get(&quot;/hello&quot;, (req, res) -&gt; {</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    return &quot;Hello, World!&quot;;</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">});</span></span></code></pre></div><hr><p>Both <code>RequestHandler</code> and <code>SimpleHandler</code> can specify the router behavior by the naming convention of the endpoint used to register the handler.</p><ul><li><p>Literal Routing: <code>/hello</code> <br> Will match exactly <code>/hello</code></p></li><li><p>Parametrized Routing: <code>/hello/:name</code> <br> Will match <code>/hello/John</code>, <code>/hello/Alice</code>, etc.</p></li><li><p>Dynamic Routing: <code>/hello/*</code> <br> Will match <code>/hello/../..</code></p></li></ul>',16)]))}const g=a(i,[["render",r]]);export{u as __pageData,g as default};
